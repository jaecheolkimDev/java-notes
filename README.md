JAVA 공부 노트
=============

1\. 기본
-------
- 상속(Inheritance)
  - 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지고 있음을 의미하는 관계이다.
  - 부모 클래스의 속성을 자식 클래스가 물려받는 개념이다.
	- 상속은 이미 만들어진 클래스의 필드와 메소드를 물려받게 함으로써 자바 코드의 중복 작성을 방지하여 코드 작성에 드는 시간과 비용을 줄일 수 있게 한다.
	 즉, 상속은 코드의 재사용을 가능케 한다.

- 다형성(Polymorphism) : 동일한 이름의 메소드를 다양한 형태로 사용할 수 있다.
	- 오버로딩과 오버라이딩을 통해 다양한 동작을 수행할 수 있습니다.
	  - 오버로딩 : 동일한 이름을 가진 메소드의 파라미터(매개변수)를 다르게 하여 처리할 수 있도록 하는 것입니다.(여러 개를 읽는다.)
	  - 오버라이딩 : 상속 관계에서 부모 클래스를 자식 클래스에서 재정의 하는 것을 말합니다.(무언가의 위에 올라탄다.)

- 접근 지정자
  - public : 클래스 내부/외부에서 모두 호출 가능.
  - private : 클래스 내부 멤버들만 호출 가능.
  - protected : 클래스 내부 메소드들은 호출 가능하며, 다른 클래스 중 상속받은 서브 클래스만 호출 가능.
  - default(생략) : 동일한 패키지 내의 모든 클래스가 호출 가능함을 의미한다.

- static : 전역변수, 전역함수
 - 객체 생성안하고 사용할수있음.
 - static멤버는 클래스당 하나만 생성되는 멤버로서 동일한 클래스의 모든 객체들이 공유한다.(꼭 공유해야 하는것만 static을 써야함.)
  :클래스당 하나씩 생긴다고 해서 클래스 멤버라고도 부른다.
  :non-static멤버는 각 객체마다 하나씩 생긴다고해서 인스턴스 멤버라고 부른다.
 - 어떤 객체도 생성되기 전 프로그램을 시작할 때 이미 생성된다. (메인이 만들어지기전에 사용준비 됨.)
  :그러므로 객체를 생성하기 전에도 static 멤버는 사용할 수 있다.
 - static 메소드는 오직 static 멤버만 접근할 수 있다.
  :static 메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없다.
  	다만 static 멤버들만 사용 가능하다.
  	그러나 인스턴스 메소드는 static 멤버들을 모두 사용할 수 있다.
 - static 메소드에서는 this 키워드를 사용할 수 없다.
  :static 메소드는 객체가 생성되지 않은 상황에서도 클래스 이름을 이용하여 호출이 가능하기 때문에
	호출 당시 실행 중인 객체를 가리키는 this 레퍼런스를 사용할 수 없다.
	
- final ( 3 군데에서 사용 )
  - final 클래스 : 클래스를 상속 할 수 없음.
  - final 메소드 : 오버라이딩 할 수 없음. ( 자식이 무조건 상속받아 사용 )
  - final 필드, 상수 정의
    - public static final : 프로그램 전체에서 공유하여 사용할 수 있는 상수

- 인터페이스 : 클래스의 청사진
- 클래스
  - 추상 클래스 : 클래스의 청사진을 만드는데 사용되지만, 메소드 구현도 가능하다.
  - 콘크리트 클래스 : 청사진의 최종구현.

- 예외(Exception) : 자바에서 기본적으로 예외가 발생했을떄 처리해주지 않으면 콜스택을 하나씩 제거하면서 최초 호출한곳까지 예외가 전파된다.

- Compile(컴파일) : 개발자가 작성한 소스코드를 바이너리 코드로 변환하는 과정을 말한다. (목적파일이 생성됨)
  - 즉, 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업이다. 이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 한다.
  - 자바의 경우, 자바가상머신(JVM)에서 실행가능한 바이트코드 형태의 클래스파일이 생성이 된다.
    - 자바 클래스 파일은 바이트 코드로 컴파일되어 static영역에 위치하게 된다. 때문에 클래스 네임만 알고 있으면 언제든 이 영역에 접근하여 클래스에 대한 정보를 얻을 수 있다.

|호출 방식|영향|종류|
|------|---|---|
|call-by-value(값에 의한 호출)        |동일한 값 복사되서 넘어가기 때문에 한쪽이 변해도 영향이 없다                    |기본 타입, 메소드 호출 인자 전달 방식|
|call-by-reference(참조에 의한 호출)  |레퍼런스 값만 복사되어 전달되는데, 동일한 객체를 가리키므로 변경에 영향을 받는다  |객체 레퍼런스, 배열                |




2\. 심화
-------
- JDBC : 관계 데이터베이스에 접근하는 자바 API.
- process : 실행 동작의 단위
  - 싱글 프로세서 : 한 컴퓨터에서 하나의 프로그램 실행.
  - thread : 하나의 process에서 실행동작의 단위
    - sleep, join, notify, notifyAll, priority, yield, wait
    - 쓰레드는 경쟁관계임. Synchronized(작업이끝날때까지 할당받는것)가 필요할 때도 있음.
    - 블럭상태 : 어떤 조건을 만족할때까지 runnable이 못되게 함.
    - lock을 요청했을때 누군가 사용중이면 기다림.
    - 스레드 객체를 생성하는 두가지 방식
      - Thred 클래스를 직접상속
      - Runnable 인터페이스를 상속
		
			yield() : 양보 - 블럭상태에 빠지는건 아님.
			sleep() : 	   잠들면서 os에게 권한을 주고 깰 때 요구함.
			join()  :	  어떤 쓰레드가 끝난 다음 작업함.
			wait()  :    쓰레드간 협업. / 작업을 일시중지.
			notify():	 block에 있는 것 중 하나가 풀림.
			notifyAll() :Block의 모든 것들이 runnable로 들어감.
			Synchronized() : lock을 얻고, 끝나면 lock을 양보함.
		
3\. 1.8 version 부터 도입
--------------

- Consumer 인터페이스 : 제네릭 타입의 매개변수를 전달받아 특정 작업을 수행해야 하는 경우 사용됩니다.
  - 인터페이스 이름이 소비자(Consumer)인 이유는 데이터(매개변수)를 소비(사용)하고 아무것도 생성(반환)하지 않기 때문입니다.

- 더블콜론(::)

> 메서드 참조 종류
> > 어떠한 메서드를 참조하여 실행하느냐에 메소드 참조도 종류가 나뉘게 된다.

|종류|람다 표현식|메서드 참조|
|------|---|---|
|정적 메서드 참조        |(x) -> ClassName.method(x)    |ClassName::method|
|인스턴스 메서드 참조    |(x) -> obj.method(x)          |obj::method|
|매개변수의 메서드 참조  |(obj, x) -> obj.method(x)      |ClassName::method|
|생성자 참조            |(x, y) -> new ClassName(x, y)  |ClassName::new|
